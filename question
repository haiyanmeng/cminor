there is no include;
how cminor compile multiple source code files?
what does it really mean to function prototype?
may I have a source file only have a function proto without having its definition? if yes, what should be done if there are multiple prototypes of the same function with different paramters or return values?
if the code only includes a fucntion proto, and there are multiple version of function prototypes.
so a function prototype without a corresponding function definition should be error? right?

are we suppose to check whether a function has a return statement; especially when a function return type should be string.
are we suppose to check whether a function misses return_stmt;
return wrong numbers of values; 
//good: missing return
f:function integer(a:integer) = {
}

array intinization more than the size: this is difficult to judge, because the size may be expressed using an expression, not an integer literal.
a:array[2*5-3] integer = {1,2,3};

if the size of array is put into function paramter, does it account as a type error, 
f:function void(a:array[5] integer) = {};

can we use a non-constant expr as the array size locally?

can we ignore the parameter name in function prototype? the prototype parameter name should not be necessary to be the same with the paramter of function def?

can unary neg op apply to boolean types? -true
type error: not operator expr only applys to boolean types!

do we need check whether a main function is provided when the source code is not empty?

can print print function;
f1:function void()= {}
f:function void() = {
    //print 1, "abc", 'a', true, false, f1(), f1;

the init_expr of for_stmt can be a decl?
    for (x:integer = 1; x + 1; x++) {
        print 1;
    }

do we allow a = {23,5}; no.
int a1[2][2]; 
a1={{1,3}, {4,5}};
hmeng@hmeng ~/c/mytest$ gcc -std=c99 -Wpedantic lvalue.c 
lvalue.c: In function ‘main’:
lvalue.c:12:4: error: expected expression before ‘{’ token
 a1={{1,3}, {4,5}};

good 1-10; not 0-9

if the code passed the name resolution, should we try to catch all the type checking error? or the first type error should exit.
when to stop?

<<<< Done:
x:integer = 5;
if (..)
	x:integer = 6;
this is legal, but this does not open a new scope.

int main() {
    int x;
    if(1) 
        x = 3;
    return 1;
}
this is legal.

int main() {
    if(1) 
        int x = 3;
    return 1;
}
func_param.c:9:3: error: expected expression before ‘int’
   int x = 3;

int main() {
    if(1) {
        int x = 3;
    }
    return 0;
}
this is also legal.

where a function prototype allowed? anywhere

can we put a function prototype after the function definition?
	yes. 

if a function name is redefined? are we supposed to resolve the fuction body? 
	yes. do as much as possible.

x:integer = 3;
z:integer = x1+3;
resolve error: the intializer of a global variable (z) should not involve another global variable (x1)!
in this case, x1 is also not defined yet. how many different errors should this contribute?
//	first find name resolution should exit;
	complain as much as possible before you exit


x:integer = 3;
z:integer = x+3;
this should be a type check error, not name resolution error.
