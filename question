a valid c-minor program? do we need check type?
exactly output the input? no divide by 0 checking? no type check?

what is the test cases we are facing? for example, function_return_type you defined it as type, but I limited it to atomic type + void?
Is this legal?

why the { after if else does not need to start a newline?
can we let all block_stmt start on the new line?
we can delete extra newlines? can we add extra newlines?



does c minor allow nested function?
	no.
Can we have function prototype or definition inside function?
	no nested function; function prototype inside function is okay;
does c minor allow empty compound stmt like {}?
	yes.
does c minor allow empty function?
	yes.
	
can we use {} willfully? can we use (()) willfully?
	yes.
is x:boolean = 1; okay?
	parser yes. type checking no.
a+1: how to only scan one +, without keep going. how to differentiate a+1 and a + 1; change the pattern of numbers. use column number to control it.
	no. there no uanry + sign; only has unary - sign. so a + -5 is right; a + +5 is wrong.

print char and string: print everything liternally without intepreting any special character.
if the user want to how these are printed? f(a*b,a + 1,b, "abc \c\c\d\d\n\d", '\n', '\0', '\r', '\t', '\\', '\b', c);
	print everything exactly.

can we throw some () like (a);
	it does not matter. But you can keep it.

stmt: matched_stmt
        | unmatched_stmt
        ;

matched_stmt: expr_stmt
        | compound_stmt
        | for_stmt
        | return_stmt
        | print_stmt
        | TOKEN_IF TOKEN_OP_LEFTPARENTHESS expr TOKEN_OP_RIGHTPARENTHESS matched_stmt TOKEN_ELSE matched_stmt
        ;

unmatched_stmt: TOKEN_IF TOKEN_OP_LEFTPARENTHESS expr TOKEN_OP_RIGHTPARENTHESS stmt
        | TOKEN_IF TOKEN_OP_LEFTPARENTHESS expr TOKEN_OP_RIGHTPARENTHESS matched_stmt TOKEN_ELSE unmatched_stmt
        ;

expr_stmt: expr TOKEN_SEMICOLON
        ;

compound_stmt: TOKEN_LEFTCURLY stmt_list TOKEN_RIGHTCURLY
        ;

for_stmt: TOKEN_OP_LEFTPARENTHESS expr_opt TOKEN_SEMICOLON expr_opt TOKEN_SEMICOLON expr_opt TOKEN_OP_RIGHTPARENTHESS stmt 
        ;

return_stmt: TOKEN_RETURN expr_opt TOKEN_SEMICOLON
        ;

print_stmt: TOKEN_PRINT expr_list_opt TOKEN_SEMICOLON
        ;

follow(for_stmt) should be in follow(stmt) according to the for_stmt production
follow(matched_stmt) should be in follow(for_stmt); according to the matched_stmt production
TOKEN_ELSE is in follow(matched_stmt)

if (a == 0)
	for(;;) 
		if (a == 1)
			print 0;
else:
	print 1;

if (a == 0)
	for(;;) 
	{
		if (a == 1)
			print 0;
	}
else:
	print 1;

the statement of for_stmt must be surrounded by {}, otherwise 

are we allow to use %left and %right and %nonassoc to define associativity?
	no, you can not.

can we just do return without any expression: return (return_stmt)
	yes. for functions whose return type is void, you can use `return ;`

can we do: for(;;) (for_stmt)
	yes.

can we do: for(i=0,j=0; i<10, j<15; i=i+1, j=j+2) (for_stmt)
	no. comma is only valiable in four places: array initialization; print argument list; function declaration; function definition.

can we do a statement without anything but a semicolon: ; (expr_stmnt)
	no.

is this legal: x: array[] char = {'a', 'b'};
	for parser, it is legal. Type checking should fail.

is this legal: puts: function void ( string ); 
	no. it should be puts: function void ( x:string );

can we have: print ; (print_stmt)
	yes. it means print out nothing.	

< and == have the same precedence? (equality_expr and relational_expr)
	it is okay. just keep them the same.

how the grouping is used in cminor? (x=1; y=2;) (x=1, y=2)
	do not mix it with the grouping feature in shell. 
	it is just normal sense of grouping things together. like the group feature in C.
