stmt: matched_stmt
        | unmatched_stmt
        ;

matched_stmt: expr_stmt
        | compound_stmt
        | for_stmt
        | return_stmt
        | print_stmt
        | TOKEN_IF TOKEN_OP_LEFTPARENTHESS expr TOKEN_OP_RIGHTPARENTHESS matched_stmt TOKEN_ELSE matched_stmt
        ;

unmatched_stmt: TOKEN_IF TOKEN_OP_LEFTPARENTHESS expr TOKEN_OP_RIGHTPARENTHESS stmt
        | TOKEN_IF TOKEN_OP_LEFTPARENTHESS expr TOKEN_OP_RIGHTPARENTHESS matched_stmt TOKEN_ELSE unmatched_stmt
        ;

expr_stmt: expr TOKEN_SEMICOLON
        ;

compound_stmt: TOKEN_LEFTCURLY stmt_list TOKEN_RIGHTCURLY
        ;

for_stmt: TOKEN_OP_LEFTPARENTHESS expr_opt TOKEN_SEMICOLON expr_opt TOKEN_SEMICOLON expr_opt TOKEN_OP_RIGHTPARENTHESS TOKEN_LEFTCURLY stmt TOKEN_RIGHTCURLY
        ;

return_stmt: TOKEN_RETURN expr_opt TOKEN_SEMICOLON
        ;

print_stmt: TOKEN_PRINT expr_list_opt TOKEN_SEMICOLON
        ;

the statement of for_stmt must be surrounded by {}, otherwise 
follow(for_stmt) should be in follow(stmt) according to the for_stmt production
follow(matched_stmt) should be in follow(for_stmt); according to the matched_stmt production
TOKEN_ELSE is in follow(matched_stmt)

if (a == 0)
	for(;;) 
		if (a == 1)
			print 0;
else:
	print 1;

if (a == 0)
	for(;;) 
	{
		if (a == 1)
			print 0;
	}
else:
	print 1;

are we allow to use %left and %right and %nonassoc to define associativity?
	no, you can not.

can we just do return without any expression: return (return_stmt)
	yes. for functions whose return type is void, you can use `return ;`

can we do: for(;;) (for_stmt)
	yes.

can we do: for(i=0,j=0; i<10, j<15; i=i+1, j=j+2) (for_stmt)
	no. comma is only valiable in four places: array initialization; print argument list; function declaration; function definition.

can we do a statement without anything but a semicolon: ; (expr_stmnt)
	no.

is this legal: x: array[] char = {'a', 'b'};
	for parser, it is legal. Type checking should fail.

is this legal: puts: function void ( string ); 
	no. it should be puts: function void ( x:string );

can we have: print ; (print_stmt)
	yes. it means print out nothing.	

< and == have the same precedence? (equality_expr and relational_expr)
	it is okay. just keep them the same.

how the grouping is used in cminor? (x=1; y=2;) (x=1, y=2)
	do not mix it with the grouping feature in shell. 
	it is just normal sense of grouping things together. like the group feature in C.
