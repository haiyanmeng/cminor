#ifndef lint
static const char yysccsid[] = "@(#)yaccpar	1.9 (Berkeley) 02/21/93";
#endif

#include <stdlib.h>
#include <string.h>

#define YYBYACC 1
#define YYMAJOR 1
#define YYMINOR 9
#define YYPATCH 20070509

#define YYEMPTY (-1)
#define yyclearin    (yychar = YYEMPTY)
#define yyerrok      (yyerrflag = 0)
#define YYRECOVERING (yyerrflag != 0)

extern int yyparse(void);

static int yygrowstack(void);
#define YYPREFIX "yy"
#line 57 "parser.bison"
typedef union {
	struct decl *decl;
	struct stmt *stmt;
	struct type *type;
	struct param_list *params;
	struct expr *expr;
	char *str;
	int n;
} YYSTYPE;
#line 78 "parser.bison"

#include <stdio.h>
#include "type.h"
#include "expr.h" 
#include "stmt.h" 
#include "decl.h" 

/*
YYSTYPE cannot be used together with %union
#define YYSTYPE char *
*/


/*
Clunky: Manually declare the interface to the scanner generated by flex. 
*/

extern char *yytext;
extern int yylex();
extern int yyerror( char *str );

/*
Clunky: Keep the final result of the parse in a global variable,
so that it can be retrieved by main().
*/

struct decl *program = 0;

#line 62 "parser.tab.c"
#define TOKEN_ARRAY 257
#define TOKEN_BOOLEAN 258
#define TOKEN_CHAR 259
#define TOKEN_ELSE 260
#define TOKEN_FALSE 261
#define TOKEN_FOR 262
#define TOKEN_FUNCTION 263
#define TOKEN_IF 264
#define TOKEN_INTEGER 265
#define TOKEN_PRINT 266
#define TOKEN_RETURN 267
#define TOKEN_STRING 268
#define TOKEN_TRUE 269
#define TOKEN_VOID 270
#define TOKEN_WHILE 271
#define TOKEN_IDENT 272
#define TOKEN_INTEGER_LITERAL 273
#define TOKEN_CHAR_LITERAL 274
#define TOKEN_STRING_LITERAL 275
#define TOKEN_COMMENT_C 276
#define TOKEN_COMMENT_CPLUSPLUS 277
#define TOKEN_OP_LEFTPARENTHESS 278
#define TOKEN_OP_RIGHTPARENTHESS 279
#define TOKEN_OP_LEFTBRACKET 280
#define TOKEN_OP_RIGHTBRACKET 281
#define TOKEN_OP_INCREMENT 282
#define TOKEN_OP_DECREMENT 283
#define TOKEN_OP_NOT 284
#define TOKEN_OP_POWER 285
#define TOKEN_OP_MUL 286
#define TOKEN_OP_DIV 287
#define TOKEN_OP_MOD 288
#define TOKEN_OP_ADD 289
#define TOKEN_OP_SUB 290
#define TOKEN_OP_LE 291
#define TOKEN_OP_LT 292
#define TOKEN_OP_GE 293
#define TOKEN_OP_GT 294
#define TOKEN_OP_EQ 295
#define TOKEN_OP_UNEQ 296
#define TOKEN_OP_AND 297
#define TOKEN_OP_OR 298
#define TOKEN_OP_ASSIGN 299
#define TOKEN_LEFTCURLY 300
#define TOKEN_RIGHTCURLY 301
#define TOKEN_COLON 302
#define TOKEN_COMMA 303
#define TOKEN_SEMICOLON 304
#define TOKEN_ERROR 305
#define YYERRCODE 256
short yylhs[] = {                                        -1,
    0,    4,    4,    3,    3,    2,    1,    1,    1,   14,
   34,   34,   35,   35,   17,   17,   16,   16,   15,   13,
   13,   13,   13,   13,   13,   13,   12,   12,   11,   11,
   10,   10,   10,   10,   10,   10,   10,    9,    9,    9,
    8,    7,    6,    5,   33,   33,   32,   32,   31,   31,
   30,   29,   29,   28,   28,   27,   27,   26,   26,   26,
   26,   26,   26,   26,   25,   25,   25,   24,   24,   24,
   24,   23,   23,   22,   22,   36,   36,   21,   21,   21,
   20,   20,   20,   19,   19,   19,   18,   18,   18,   18,
   18,
};
short yylen[] = {                                         2,
    1,    2,    0,    1,    1,    5,    6,    4,    4,    5,
    1,    3,    1,    3,    0,    1,    1,    3,    3,    1,
    1,    1,    1,    1,    4,    5,    0,    2,    1,    1,
    1,    1,    1,    1,    1,    9,    7,    5,    7,    9,
    2,    3,    3,    3,    0,    1,    1,    3,    0,    1,
    1,    1,    3,    1,    3,    1,    3,    1,    3,    3,
    3,    3,    3,    3,    1,    3,    3,    1,    3,    3,
    3,    1,    3,    1,    2,    1,    1,    1,    2,    2,
    1,    4,    4,    1,    1,    3,    1,    1,    1,    1,
    1,
};
short yydefred[] = {                                      0,
    0,    0,    4,    5,    0,    1,    0,    2,    0,   22,
   21,    0,   20,   23,   24,    0,    0,    0,    0,    0,
    8,    0,    9,   91,   90,   85,   87,   88,   89,    0,
    0,   77,   76,   84,   81,    0,    0,   72,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,   51,
   11,    0,    0,    6,    0,   25,    0,    0,   79,   80,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,   75,    0,    0,   16,    0,
   13,    0,    0,    7,    0,    0,    0,    0,    0,   31,
   35,   34,   33,   32,   30,   29,    0,    0,    0,   86,
   47,    0,    0,    0,   73,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,   26,    0,    0,
    0,   10,   12,    0,   53,    0,    0,    0,   50,    0,
   28,   42,   41,    0,   83,   82,   19,   18,   14,    0,
    0,   44,   43,   48,    0,    0,    0,    0,   38,    0,
    0,    0,   39,   37,    0,   40,   36,
};
short yydgoto[] = {                                       2,
    3,    4,   90,    6,   91,   92,   93,   94,   95,   96,
   97,   98,   16,   17,   78,   79,   80,   34,   35,   36,
   37,   48,   39,   40,   41,   42,   43,   49,   50,   99,
  130,  102,  103,   52,   82,   45,
};
short yysindex[] = {                                   -202,
 -212,    0,    0,    0, -202,    0,  313,    0, -180,    0,
    0,  327,    0,    0,    0, -263, -238, -126, -173, -256,
    0, -192,    0,    0,    0,    0,    0,    0,    0, -104,
  327,    0,    0,    0,    0, -266, -259,    0, -175, -111,
 -208,  132, -184, -277, -104, -150, -256, -168, -174,    0,
    0, -171, -146,    0, -145,    0, -104, -104,    0,    0,
 -104, -104, -104, -104, -104, -104, -104, -104, -104, -104,
 -104, -104, -104,  327, -104,    0, -157, -163,    0, -129,
    0, -258, -104,    0, -127, -125, -104, -104, -212,    0,
    0,    0,    0,    0,    0,    0, -146, -142, -144,    0,
    0, -141, -113, -118,    0, -175, -175, -175, -111, -111,
 -208, -208, -208, -208, -208, -208,  132,    0, -184,  327,
 -150,    0,    0, -256,    0, -104, -104, -137,    0, -132,
    0,    0,    0, -104,    0,    0,    0,    0,    0, -131,
 -101,    0,    0,    0, -104, -146, -123,  -81,    0, -104,
 -146,  -97,    0,    0, -146,    0,    0,
};
short yyrindex[] = {                                    184,
    0,    0,    0,    0,  184,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,  -71,  -50,    0,   -8,   76,
  139, -272, -239,    0,    0,  -90,    0,  -29, -205,    0,
    0,    0,  -88,    0,    0,    0,  -24,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,   -9,    0,    0,
    0,    0,    0,    0,    0,    0,  -70,  -28,  -95,    0,
    0,    0,    0,    0,    0,    0,  -88,    0,    0,    0,
    0, -271,    0,    0,    0,   13,   34,   55,   97,  118,
  160,  181,  202,  223,  244,  265, -210,    0, -162,    0,
    0,    0,    0,    0,    0,  -28,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,  -28,    0,    0, -189,    0,   -2,
    0,    0,    0,    0,    0,    0,    0,
};
short yygindex[] = {                                      0,
    0,    0,   92,  286,    0,    0,  275,    0, -116, -140,
  152,  215,  -11,    0,    0,  197,    0,    0,    0,    0,
    0,  -15,  143,   37,  377,  246,  258,  321,  257,  -20,
   11,    0,  267,  -45,    0,    0,
};
#define YYTABLESIZE 597
short yytable[] = {                                      51,
   19,   81,   38,   74,   24,  148,   56,   46,   56,   55,
  154,   57,   25,   58,  157,   26,   27,   28,   29,   56,
   75,   30,   59,   60,   56,   56,   51,   32,   56,   76,
   56,   56,   46,   33,  153,   20,  101,  104,  156,   54,
   21,   54,  123,   47,  124,  105,   38,   38,   38,   38,
   38,   38,   38,   38,   38,   38,   38,   38,   54,   38,
   22,   54,  118,   54,   54,   23,  101,  129,   57,    1,
   57,   29,   29,   52,   29,   52,   29,   29,  139,   29,
   65,   66,   29,   29,   29,   29,   57,   57,   29,    7,
   57,    5,   57,   57,   29,   52,    5,   52,   52,   18,
   29,  109,  110,   51,   46,  129,  141,   53,  137,   61,
   29,   29,   73,  144,   24,   85,   55,   86,   55,   87,
   88,   77,   25,   75,  129,   89,   27,   28,   29,  129,
   83,   30,   84,  100,   24,   55,  140,   32,   55,  121,
   55,   55,   25,   33,  120,   26,   27,   28,   29,  122,
  126,   30,  127,   53,   31,  147,   24,   32,  132,  133,
  152,  134,  136,   33,   25,  135,  142,   26,   27,   28,
   29,  143,  145,   30,   62,   63,   64,  146,  151,   32,
  150,  155,   85,    3,   85,   33,   85,   85,   15,   85,
   85,   85,   85,   85,   85,   85,   85,   85,   85,   85,
   85,   85,   85,   85,  106,  107,  108,   78,   85,   78,
   78,   78,   27,   78,   78,   78,   78,   78,   78,   78,
   78,   78,   78,   78,   78,   78,   78,   78,   74,   78,
   74,   78,   78,   45,   74,   74,   74,   74,   74,   74,
   74,   74,   74,   74,   74,   74,   74,   74,   74,   72,
   74,   72,   74,   74,   45,   72,   72,   72,   72,   72,
   72,   72,   72,   72,   72,   72,   72,   72,   72,   17,
   68,   72,   68,   72,   72,   49,   49,   68,   68,   68,
   68,   68,   68,   68,   68,   68,   68,   68,   68,   68,
    8,   69,   68,   69,   68,   68,   54,  149,   69,   69,
   69,   69,   69,   69,   69,   69,   69,   69,   69,   69,
   69,  131,   70,   69,   70,   69,   69,  138,  117,   70,
   70,   70,   70,   70,   70,   70,   70,   70,   70,   70,
   70,   70,  119,   71,   70,   71,   70,   70,   44,  125,
   71,   71,   71,   71,   71,   71,   71,   71,   71,   71,
   71,   71,   71,  128,   65,   71,   65,   71,   71,    0,
    0,    0,    0,    0,   65,   65,   65,   65,   65,   65,
   65,   65,   65,   65,    0,   66,   65,   66,   65,   65,
    0,    0,    0,    0,    0,   66,   66,   66,   66,   66,
   66,   66,   66,   66,   66,    0,   67,   66,   67,   66,
   66,    0,    0,    0,    0,    0,   67,   67,   67,   67,
   67,   67,   67,   67,   67,   67,    0,   58,   67,   58,
   67,   67,   67,   68,   69,   70,   71,   72,    0,   58,
   58,   58,   58,   58,   58,   58,   58,    0,   60,   58,
   60,   58,   58,  111,  112,  113,  114,  115,  116,    0,
   60,   60,   60,   60,   60,   60,   60,   60,    0,   59,
   60,   59,   60,   60,    0,    0,    0,    0,    0,    0,
    0,   59,   59,   59,   59,   59,   59,   59,   59,    0,
   62,   59,   62,   59,   59,    0,    0,    0,    0,    0,
    0,    0,   62,   62,   62,   62,   62,   62,   62,   62,
    0,   61,   62,   61,   62,   62,    0,    0,    0,    0,
    0,    0,    0,   61,   61,   61,   61,   61,   61,   61,
   61,    0,   63,   61,   63,   61,   61,    0,    0,    0,
    0,    0,    0,    0,   63,   63,   63,   63,   63,   63,
   63,   63,    0,   64,   63,   64,   63,   63,    0,    0,
    0,    0,    0,    0,    0,   64,   64,   64,   64,   64,
   64,   64,   64,    0,    0,   64,    0,   64,   64,    9,
   10,   11,    0,    0,    0,   12,    0,   13,    0,    0,
   14,    0,   15,    9,   10,   11,    0,    0,    0,    0,
    0,   13,    0,    0,   14,    0,   15,
};
short yycheck[] = {                                      20,
   12,   47,   18,  281,  261,  146,  279,  279,  281,   30,
  151,  278,  269,  280,  155,  272,  273,  274,  275,   31,
  298,  278,  282,  283,  297,  298,   47,  284,  301,   45,
  303,  304,  304,  290,  151,  299,   57,   58,  155,  279,
  304,  281,  301,  300,  303,   61,   62,   63,   64,   65,
   66,   67,   68,   69,   70,   71,   72,   73,  298,   75,
  299,  301,   74,  303,  304,  304,   87,   88,  279,  272,
  281,  261,  262,  279,  264,  281,  266,  267,  124,  269,
  289,  290,  272,  273,  274,  275,  297,  298,  278,  302,
  301,    0,  303,  304,  284,  301,    5,  303,  304,  280,
  290,   65,   66,  124,  278,  126,  127,  300,  120,  285,
  300,  301,  297,  134,  261,  262,  279,  264,  281,  266,
  267,  272,  269,  298,  145,  272,  273,  274,  275,  150,
  299,  278,  304,  279,  261,  298,  126,  284,  301,  303,
  303,  304,  269,  290,  302,  272,  273,  274,  275,  279,
  278,  278,  278,  300,  281,  145,  261,  284,  301,  304,
  150,  303,  281,  290,  269,  279,  304,  272,  273,  274,
  275,  304,  304,  278,  286,  287,  288,  279,  260,  284,
  304,  279,  278,    0,  280,  290,  282,  283,  279,  285,
  286,  287,  288,  289,  290,  291,  292,  293,  294,  295,
  296,  297,  298,  299,   62,   63,   64,  279,  304,  281,
  282,  283,  301,  285,  286,  287,  288,  289,  290,  291,
  292,  293,  294,  295,  296,  297,  298,  299,  279,  301,
  281,  303,  304,  304,  285,  286,  287,  288,  289,  290,
  291,  292,  293,  294,  295,  296,  297,  298,  299,  279,
  301,  281,  303,  304,  279,  285,  286,  287,  288,  289,
  290,  291,  292,  293,  294,  295,  296,  297,  298,  279,
  279,  301,  281,  303,  304,  304,  279,  286,  287,  288,
  289,  290,  291,  292,  293,  294,  295,  296,  297,  298,
    5,  279,  301,  281,  303,  304,   22,  146,  286,  287,
  288,  289,  290,  291,  292,  293,  294,  295,  296,  297,
  298,   97,  279,  301,  281,  303,  304,  121,   73,  286,
  287,  288,  289,  290,  291,  292,  293,  294,  295,  296,
  297,  298,   75,  279,  301,  281,  303,  304,   18,   83,
  286,  287,  288,  289,  290,  291,  292,  293,  294,  295,
  296,  297,  298,   87,  279,  301,  281,  303,  304,   -1,
   -1,   -1,   -1,   -1,  289,  290,  291,  292,  293,  294,
  295,  296,  297,  298,   -1,  279,  301,  281,  303,  304,
   -1,   -1,   -1,   -1,   -1,  289,  290,  291,  292,  293,
  294,  295,  296,  297,  298,   -1,  279,  301,  281,  303,
  304,   -1,   -1,   -1,   -1,   -1,  289,  290,  291,  292,
  293,  294,  295,  296,  297,  298,   -1,  279,  301,  281,
  303,  304,  291,  292,  293,  294,  295,  296,   -1,  291,
  292,  293,  294,  295,  296,  297,  298,   -1,  279,  301,
  281,  303,  304,   67,   68,   69,   70,   71,   72,   -1,
  291,  292,  293,  294,  295,  296,  297,  298,   -1,  279,
  301,  281,  303,  304,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,  291,  292,  293,  294,  295,  296,  297,  298,   -1,
  279,  301,  281,  303,  304,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,  291,  292,  293,  294,  295,  296,  297,  298,
   -1,  279,  301,  281,  303,  304,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,  291,  292,  293,  294,  295,  296,  297,
  298,   -1,  279,  301,  281,  303,  304,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,  291,  292,  293,  294,  295,  296,
  297,  298,   -1,  279,  301,  281,  303,  304,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,  291,  292,  293,  294,  295,
  296,  297,  298,   -1,   -1,  301,   -1,  303,  304,  257,
  258,  259,   -1,   -1,   -1,  263,   -1,  265,   -1,   -1,
  268,   -1,  270,  257,  258,  259,   -1,   -1,   -1,   -1,
   -1,  265,   -1,   -1,  268,   -1,  270,
};
#define YYFINAL 2
#ifndef YYDEBUG
#define YYDEBUG 0
#endif
#define YYMAXTOKEN 305
#if YYDEBUG
char *yyname[] = {
"end-of-file",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,"TOKEN_ARRAY","TOKEN_BOOLEAN",
"TOKEN_CHAR","TOKEN_ELSE","TOKEN_FALSE","TOKEN_FOR","TOKEN_FUNCTION","TOKEN_IF",
"TOKEN_INTEGER","TOKEN_PRINT","TOKEN_RETURN","TOKEN_STRING","TOKEN_TRUE",
"TOKEN_VOID","TOKEN_WHILE","TOKEN_IDENT","TOKEN_INTEGER_LITERAL",
"TOKEN_CHAR_LITERAL","TOKEN_STRING_LITERAL","TOKEN_COMMENT_C",
"TOKEN_COMMENT_CPLUSPLUS","TOKEN_OP_LEFTPARENTHESS","TOKEN_OP_RIGHTPARENTHESS",
"TOKEN_OP_LEFTBRACKET","TOKEN_OP_RIGHTBRACKET","TOKEN_OP_INCREMENT",
"TOKEN_OP_DECREMENT","TOKEN_OP_NOT","TOKEN_OP_POWER","TOKEN_OP_MUL",
"TOKEN_OP_DIV","TOKEN_OP_MOD","TOKEN_OP_ADD","TOKEN_OP_SUB","TOKEN_OP_LE",
"TOKEN_OP_LT","TOKEN_OP_GE","TOKEN_OP_GT","TOKEN_OP_EQ","TOKEN_OP_UNEQ",
"TOKEN_OP_AND","TOKEN_OP_OR","TOKEN_OP_ASSIGN","TOKEN_LEFTCURLY",
"TOKEN_RIGHTCURLY","TOKEN_COLON","TOKEN_COMMA","TOKEN_SEMICOLON","TOKEN_ERROR",
};
char *yyrule[] = {
"$accept : program",
"program : translation_unit",
"translation_unit : external_decl translation_unit",
"translation_unit :",
"external_decl : decl",
"external_decl : func_definition",
"func_definition : TOKEN_IDENT TOKEN_COLON func_type TOKEN_OP_ASSIGN compound_stmt",
"decl : TOKEN_IDENT TOKEN_COLON type TOKEN_OP_ASSIGN initializer TOKEN_SEMICOLON",
"decl : TOKEN_IDENT TOKEN_COLON type TOKEN_SEMICOLON",
"decl : TOKEN_IDENT TOKEN_COLON func_type TOKEN_SEMICOLON",
"func_type : TOKEN_FUNCTION type TOKEN_OP_LEFTPARENTHESS param_list_opt TOKEN_OP_RIGHTPARENTHESS",
"initializer : expr",
"initializer : TOKEN_LEFTCURLY initializer_list TOKEN_RIGHTCURLY",
"initializer_list : initializer",
"initializer_list : initializer_list TOKEN_COMMA initializer",
"param_list_opt :",
"param_list_opt : param_list",
"param_list : param",
"param_list : param TOKEN_COMMA param_list",
"param : TOKEN_IDENT TOKEN_COLON type",
"type : TOKEN_INTEGER",
"type : TOKEN_CHAR",
"type : TOKEN_BOOLEAN",
"type : TOKEN_STRING",
"type : TOKEN_VOID",
"type : TOKEN_ARRAY TOKEN_OP_LEFTBRACKET TOKEN_OP_RIGHTBRACKET type",
"type : TOKEN_ARRAY TOKEN_OP_LEFTBRACKET logical_or_expr TOKEN_OP_RIGHTBRACKET type",
"stmt_list :",
"stmt_list : stmt stmt_list",
"stmt : matched_stmt",
"stmt : unmatched_stmt",
"matched_stmt : external_decl",
"matched_stmt : expr_stmt",
"matched_stmt : compound_stmt",
"matched_stmt : return_stmt",
"matched_stmt : print_stmt",
"matched_stmt : TOKEN_FOR TOKEN_OP_LEFTPARENTHESS expr_opt TOKEN_SEMICOLON expr_opt TOKEN_SEMICOLON expr_opt TOKEN_OP_RIGHTPARENTHESS matched_stmt",
"matched_stmt : TOKEN_IF TOKEN_OP_LEFTPARENTHESS expr TOKEN_OP_RIGHTPARENTHESS matched_stmt TOKEN_ELSE matched_stmt",
"unmatched_stmt : TOKEN_IF TOKEN_OP_LEFTPARENTHESS expr TOKEN_OP_RIGHTPARENTHESS stmt",
"unmatched_stmt : TOKEN_IF TOKEN_OP_LEFTPARENTHESS expr TOKEN_OP_RIGHTPARENTHESS matched_stmt TOKEN_ELSE unmatched_stmt",
"unmatched_stmt : TOKEN_FOR TOKEN_OP_LEFTPARENTHESS expr_opt TOKEN_SEMICOLON expr_opt TOKEN_SEMICOLON expr_opt TOKEN_OP_RIGHTPARENTHESS unmatched_stmt",
"expr_stmt : expr TOKEN_SEMICOLON",
"compound_stmt : TOKEN_LEFTCURLY stmt_list TOKEN_RIGHTCURLY",
"return_stmt : TOKEN_RETURN expr_opt TOKEN_SEMICOLON",
"print_stmt : TOKEN_PRINT expr_list_opt TOKEN_SEMICOLON",
"expr_list_opt :",
"expr_list_opt : expr_list",
"expr_list : expr",
"expr_list : expr_list TOKEN_COMMA expr",
"expr_opt :",
"expr_opt : expr",
"expr : assignment_expr",
"assignment_expr : logical_or_expr",
"assignment_expr : unary_expr TOKEN_OP_ASSIGN assignment_expr",
"logical_or_expr : logical_and_expr",
"logical_or_expr : logical_or_expr TOKEN_OP_OR logical_and_expr",
"logical_and_expr : relational_expr",
"logical_and_expr : logical_and_expr TOKEN_OP_AND relational_expr",
"relational_expr : add_expr",
"relational_expr : relational_expr TOKEN_OP_LT add_expr",
"relational_expr : relational_expr TOKEN_OP_LE add_expr",
"relational_expr : relational_expr TOKEN_OP_GT add_expr",
"relational_expr : relational_expr TOKEN_OP_GE add_expr",
"relational_expr : relational_expr TOKEN_OP_EQ add_expr",
"relational_expr : relational_expr TOKEN_OP_UNEQ add_expr",
"add_expr : mul_expr",
"add_expr : add_expr TOKEN_OP_ADD mul_expr",
"add_expr : add_expr TOKEN_OP_SUB mul_expr",
"mul_expr : power_expr",
"mul_expr : mul_expr TOKEN_OP_MUL power_expr",
"mul_expr : mul_expr TOKEN_OP_DIV power_expr",
"mul_expr : mul_expr TOKEN_OP_MOD power_expr",
"power_expr : unary_expr",
"power_expr : power_expr TOKEN_OP_POWER unary_expr",
"unary_expr : increment_expr",
"unary_expr : unary_operator unary_expr",
"unary_operator : TOKEN_OP_SUB",
"unary_operator : TOKEN_OP_NOT",
"increment_expr : postfix_expr",
"increment_expr : increment_expr TOKEN_OP_INCREMENT",
"increment_expr : increment_expr TOKEN_OP_DECREMENT",
"postfix_expr : primary_expr",
"postfix_expr : postfix_expr TOKEN_OP_LEFTBRACKET expr TOKEN_OP_RIGHTBRACKET",
"postfix_expr : postfix_expr TOKEN_OP_LEFTPARENTHESS expr_list_opt TOKEN_OP_RIGHTPARENTHESS",
"primary_expr : constant",
"primary_expr : TOKEN_IDENT",
"primary_expr : TOKEN_OP_LEFTPARENTHESS expr TOKEN_OP_RIGHTPARENTHESS",
"constant : TOKEN_INTEGER_LITERAL",
"constant : TOKEN_CHAR_LITERAL",
"constant : TOKEN_STRING_LITERAL",
"constant : TOKEN_TRUE",
"constant : TOKEN_FALSE",
};
#endif
#if YYDEBUG
#include <stdio.h>
#endif

/* define the initial stack-sizes */
#ifdef YYSTACKSIZE
#undef YYMAXDEPTH
#define YYMAXDEPTH  YYSTACKSIZE
#else
#ifdef YYMAXDEPTH
#define YYSTACKSIZE YYMAXDEPTH
#else
#define YYSTACKSIZE 10000
#define YYMAXDEPTH  10000
#endif
#endif

#define YYINITSTACKSIZE 500

int      yydebug;
int      yynerrs;
int      yyerrflag;
int      yychar;
short   *yyssp;
YYSTYPE *yyvsp;
YYSTYPE  yyval;
YYSTYPE  yylval;

/* variables for the parser stack */
static short   *yyss;
static short   *yysslim;
static YYSTYPE *yyvs;
static int      yystacksize;
#line 355 "parser.bison"

/*
This function will be called by bison if the parse should
encounter an error.  In principle, "str" will contain something
useful.  In practice, it often does not.
*/

int yyerror( char *str )
{
	printf("parse error: %s!\n",str);
}
#line 494 "parser.tab.c"
/* allocate initial stack or double stack size, up to YYMAXDEPTH */
static int yygrowstack(void)
{
    int newsize, i;
    short *newss;
    YYSTYPE *newvs;

    if ((newsize = yystacksize) == 0)
        newsize = YYINITSTACKSIZE;
    else if (newsize >= YYMAXDEPTH)
        return -1;
    else if ((newsize *= 2) > YYMAXDEPTH)
        newsize = YYMAXDEPTH;

    i = yyssp - yyss;
    newss = (yyss != 0)
          ? (short *)realloc(yyss, newsize * sizeof(*newss))
          : (short *)malloc(newsize * sizeof(*newss));
    if (newss == 0)
        return -1;

    yyss  = newss;
    yyssp = newss + i;
    newvs = (yyvs != 0)
          ? (YYSTYPE *)realloc(yyvs, newsize * sizeof(*newvs))
          : (YYSTYPE *)malloc(newsize * sizeof(*newvs));
    if (newvs == 0)
        return -1;

    yyvs = newvs;
    yyvsp = newvs + i;
    yystacksize = newsize;
    yysslim = yyss + newsize - 1;
    return 0;
}

#define YYABORT goto yyabort
#define YYREJECT goto yyabort
#define YYACCEPT goto yyaccept
#define YYERROR goto yyerrlab
int
yyparse(void)
{
    register int yym, yyn, yystate;
#if YYDEBUG
    register const char *yys;

    if ((yys = getenv("YYDEBUG")) != 0)
    {
        yyn = *yys;
        if (yyn >= '0' && yyn <= '9')
            yydebug = yyn - '0';
    }
#endif

    yynerrs = 0;
    yyerrflag = 0;
    yychar = YYEMPTY;

    if (yyss == NULL && yygrowstack()) goto yyoverflow;
    yyssp = yyss;
    yyvsp = yyvs;
    *yyssp = yystate = 0;

yyloop:
    if ((yyn = yydefred[yystate]) != 0) goto yyreduce;
    if (yychar < 0)
    {
        if ((yychar = yylex()) < 0) yychar = 0;
#if YYDEBUG
        if (yydebug)
        {
            yys = 0;
            if (yychar <= YYMAXTOKEN) yys = yyname[yychar];
            if (!yys) yys = "illegal-symbol";
            printf("%sdebug: state %d, reading %d (%s)\n",
                    YYPREFIX, yystate, yychar, yys);
        }
#endif
    }
    if ((yyn = yysindex[yystate]) && (yyn += yychar) >= 0 &&
            yyn <= YYTABLESIZE && yycheck[yyn] == yychar)
    {
#if YYDEBUG
        if (yydebug)
            printf("%sdebug: state %d, shifting to state %d\n",
                    YYPREFIX, yystate, yytable[yyn]);
#endif
        if (yyssp >= yysslim && yygrowstack())
        {
            goto yyoverflow;
        }
        *++yyssp = yystate = yytable[yyn];
        *++yyvsp = yylval;
        yychar = YYEMPTY;
        if (yyerrflag > 0)  --yyerrflag;
        goto yyloop;
    }
    if ((yyn = yyrindex[yystate]) && (yyn += yychar) >= 0 &&
            yyn <= YYTABLESIZE && yycheck[yyn] == yychar)
    {
        yyn = yytable[yyn];
        goto yyreduce;
    }
    if (yyerrflag) goto yyinrecovery;

    yyerror("syntax error");

#ifdef lint
    goto yyerrlab;
#endif

yyerrlab:
    ++yynerrs;

yyinrecovery:
    if (yyerrflag < 3)
    {
        yyerrflag = 3;
        for (;;)
        {
            if ((yyn = yysindex[*yyssp]) && (yyn += YYERRCODE) >= 0 &&
                    yyn <= YYTABLESIZE && yycheck[yyn] == YYERRCODE)
            {
#if YYDEBUG
                if (yydebug)
                    printf("%sdebug: state %d, error recovery shifting\
 to state %d\n", YYPREFIX, *yyssp, yytable[yyn]);
#endif
                if (yyssp >= yysslim && yygrowstack())
                {
                    goto yyoverflow;
                }
                *++yyssp = yystate = yytable[yyn];
                *++yyvsp = yylval;
                goto yyloop;
            }
            else
            {
#if YYDEBUG
                if (yydebug)
                    printf("%sdebug: error recovery discarding state %d\n",
                            YYPREFIX, *yyssp);
#endif
                if (yyssp <= yyss) goto yyabort;
                --yyssp;
                --yyvsp;
            }
        }
    }
    else
    {
        if (yychar == 0) goto yyabort;
#if YYDEBUG
        if (yydebug)
        {
            yys = 0;
            if (yychar <= YYMAXTOKEN) yys = yyname[yychar];
            if (!yys) yys = "illegal-symbol";
            printf("%sdebug: state %d, error recovery discards token %d (%s)\n",
                    YYPREFIX, yystate, yychar, yys);
        }
#endif
        yychar = YYEMPTY;
        goto yyloop;
    }

yyreduce:
#if YYDEBUG
    if (yydebug)
        printf("%sdebug: state %d, reducing by rule %d (%s)\n",
                YYPREFIX, yystate, yyn, yyrule[yyn]);
#endif
    yym = yylen[yyn];
    if (yym)
        yyval = yyvsp[1-yym];
    else
        memset(&yyval, 0, sizeof yyval);
    switch (yyn)
    {
case 1:
#line 115 "parser.bison"
{ program = yyvsp[0].decl; return 0; }
break;
case 2:
#line 119 "parser.bison"
{ yyvsp[-1].decl->next = yyvsp[0].decl; yyval.decl = yyvsp[-1].decl; }
break;
case 3:
#line 121 "parser.bison"
{ yyval.decl = 0; }
break;
case 4:
#line 125 "parser.bison"
{ yyval.decl = yyvsp[0].decl; }
break;
case 5:
#line 127 "parser.bison"
{ yyval.decl = yyvsp[0].decl; }
break;
case 6:
#line 131 "parser.bison"
{ yyval.decl = decl_create(yyvsp[-4].str, yyvsp[-2].type, 0, yyvsp[0].stmt, 0); }
break;
case 7:
#line 135 "parser.bison"
{ yyval.decl = decl_create(yyvsp[-5].str, yyvsp[-3].type, yyvsp[-1].expr, 0, 0); }
break;
case 8:
#line 137 "parser.bison"
{ yyval.decl = decl_create(yyvsp[-3].str, yyvsp[-1].type, 0, 0, 0); }
break;
case 9:
#line 139 "parser.bison"
{ yyval.decl = decl_create(yyvsp[-3].str, yyvsp[-1].type, 0, 0, 0); }
break;
case 10:
#line 143 "parser.bison"
{ yyval.type = type_create(TYPE_FUNCTION, yyvsp[-1].params, 0, yyvsp[-3].type); }
break;
case 11:
#line 147 "parser.bison"
{ yyval.expr = yyvsp[0].expr; }
break;
case 12:
#line 149 "parser.bison"
{ yyval.expr = expr_create(EXPR_LEFTCURLY, 0, yyvsp[-1].expr); }
break;
case 13:
#line 153 "parser.bison"
{ yyval.expr = yyvsp[0].expr; }
break;
case 14:
#line 155 "parser.bison"
{ yyval.expr = expr_create(EXPR_COMMA, yyvsp[-2].expr, yyvsp[0].expr); }
break;
case 15:
#line 159 "parser.bison"
{ yyval.params = 0; }
break;
case 16:
#line 161 "parser.bison"
{ yyval.params = yyvsp[0].params; }
break;
case 17:
#line 165 "parser.bison"
{ yyval.params = yyvsp[0].params; }
break;
case 18:
#line 167 "parser.bison"
{ yyvsp[-2].params->next = yyvsp[0].params; yyval.params = yyvsp[-2].params; }
break;
case 19:
#line 171 "parser.bison"
{ yyval.params = param_list_create(yyvsp[-2].str, yyvsp[0].type, 0); }
break;
case 20:
#line 174 "parser.bison"
{ yyval.type = type_create(TYPE_INTEGER, 0, 0, 0); }
break;
case 21:
#line 176 "parser.bison"
{ yyval.type = type_create(TYPE_CHARACTER, 0, 0, 0); }
break;
case 22:
#line 178 "parser.bison"
{ yyval.type = type_create(TYPE_BOOLEAN, 0, 0, 0); }
break;
case 23:
#line 180 "parser.bison"
{ yyval.type = type_create(TYPE_STRING, 0, 0, 0); }
break;
case 24:
#line 182 "parser.bison"
{ yyval.type = type_create(TYPE_VOID, 0, 0, 0); }
break;
case 25:
#line 184 "parser.bison"
{ yyval.type = type_create(TYPE_ARRAY, 0, 0, yyvsp[0].type); }
break;
case 26:
#line 186 "parser.bison"
{ yyval.type = type_create(TYPE_ARRAY, 0, yyvsp[-2].expr, yyvsp[0].type); }
break;
case 27:
#line 190 "parser.bison"
{ yyval.stmt = 0; }
break;
case 28:
#line 192 "parser.bison"
{ yyvsp[-1].stmt->next = yyvsp[0].stmt; yyval.stmt = yyvsp[-1].stmt; }
break;
case 29:
#line 196 "parser.bison"
{ yyval.stmt = yyvsp[0].stmt; }
break;
case 30:
#line 198 "parser.bison"
{ yyval.stmt = yyvsp[0].stmt; }
break;
case 31:
#line 202 "parser.bison"
{ yyval.stmt = stmt_create(STMT_DECL, yyvsp[0].decl, 0, 0, 0, 0, 0, 0); }
break;
case 32:
#line 204 "parser.bison"
{ yyval.stmt = yyvsp[0].stmt; }
break;
case 33:
#line 206 "parser.bison"
{ yyval.stmt = yyvsp[0].stmt; }
break;
case 34:
#line 208 "parser.bison"
{ yyval.stmt = yyvsp[0].stmt; }
break;
case 35:
#line 210 "parser.bison"
{ yyval.stmt = yyvsp[0].stmt; }
break;
case 36:
#line 212 "parser.bison"
{ yyval.stmt = stmt_create(STMT_FOR, 0, yyvsp[-6].expr, yyvsp[-4].expr, yyvsp[-2].expr, yyvsp[0].stmt, 0, 0); }
break;
case 37:
#line 214 "parser.bison"
{ yyval.stmt = stmt_create(STMT_IF_ELSE, 0, 0, yyvsp[-4].expr, 0, yyvsp[-2].stmt, yyvsp[0].stmt, 0); }
break;
case 38:
#line 218 "parser.bison"
{ yyval.stmt = stmt_create(STMT_IF_ELSE, 0, 0, yyvsp[-2].expr, 0, yyvsp[0].stmt, 0, 0); }
break;
case 39:
#line 220 "parser.bison"
{ yyval.stmt = stmt_create(STMT_IF_ELSE, 0, 0, yyvsp[-4].expr, 0, yyvsp[-2].stmt, yyvsp[0].stmt, 0); }
break;
case 40:
#line 222 "parser.bison"
{ yyval.stmt = stmt_create(STMT_FOR, 0, yyvsp[-6].expr, yyvsp[-4].expr, yyvsp[-2].expr, yyvsp[0].stmt, 0, 0); }
break;
case 41:
#line 226 "parser.bison"
{ yyval.stmt = stmt_create(STMT_EXPR, 0, 0, yyvsp[-1].expr, 0, 0, 0, 0); }
break;
case 42:
#line 230 "parser.bison"
{ yyval.stmt = stmt_create(STMT_BLOCK, 0, 0, 0, 0, yyvsp[-1].stmt, 0, 0); }
break;
case 43:
#line 234 "parser.bison"
{ yyval.stmt = stmt_create(STMT_RETURN, 0, 0, yyvsp[-1].expr, 0, 0, 0, 0); }
break;
case 44:
#line 238 "parser.bison"
{ yyval.stmt = stmt_create(STMT_PRINT, 0, 0, yyvsp[-1].expr, 0, 0, 0, 0); }
break;
case 45:
#line 242 "parser.bison"
{ yyval.expr = 0; }
break;
case 46:
#line 244 "parser.bison"
{ yyval.expr = yyvsp[0].expr; }
break;
case 48:
#line 249 "parser.bison"
{ yyval.expr = expr_create(EXPR_COMMA, yyvsp[-2].expr, yyvsp[0].expr); }
break;
case 53:
#line 261 "parser.bison"
{ yyval.expr = expr_create(EXPR_ASSIGN, yyvsp[-2].expr, yyvsp[0].expr); }
break;
case 55:
#line 266 "parser.bison"
{ yyval.expr = expr_create(EXPR_OR, yyvsp[-2].expr, yyvsp[0].expr); }
break;
case 57:
#line 271 "parser.bison"
{ yyval.expr = expr_create(EXPR_AND, yyvsp[-2].expr, yyvsp[0].expr); }
break;
case 59:
#line 277 "parser.bison"
{ yyval.expr = expr_create(EXPR_LT, yyvsp[-2].expr, yyvsp[0].expr); }
break;
case 60:
#line 279 "parser.bison"
{ yyval.expr = expr_create(EXPR_LE, yyvsp[-2].expr, yyvsp[0].expr); }
break;
case 61:
#line 281 "parser.bison"
{ yyval.expr = expr_create(EXPR_GT, yyvsp[-2].expr, yyvsp[0].expr); }
break;
case 62:
#line 283 "parser.bison"
{ yyval.expr = expr_create(EXPR_GE, yyvsp[-2].expr, yyvsp[0].expr); }
break;
case 63:
#line 285 "parser.bison"
{ yyval.expr = expr_create(EXPR_EQ, yyvsp[-2].expr, yyvsp[0].expr); }
break;
case 64:
#line 287 "parser.bison"
{ yyval.expr = expr_create(EXPR_UNEQ, yyvsp[-2].expr, yyvsp[0].expr); }
break;
case 66:
#line 292 "parser.bison"
{ yyval.expr = expr_create(EXPR_ADD, yyvsp[-2].expr, yyvsp[0].expr); }
break;
case 67:
#line 294 "parser.bison"
{ yyval.expr = expr_create(EXPR_SUB, yyvsp[-2].expr, yyvsp[0].expr); }
break;
case 69:
#line 299 "parser.bison"
{ yyval.expr = expr_create(EXPR_MUL, yyvsp[-2].expr, yyvsp[0].expr); }
break;
case 70:
#line 301 "parser.bison"
{ yyval.expr = expr_create(EXPR_DIV, yyvsp[-2].expr, yyvsp[0].expr); }
break;
case 71:
#line 303 "parser.bison"
{ yyval.expr = expr_create(EXPR_MOD, yyvsp[-2].expr, yyvsp[0].expr); }
break;
case 73:
#line 308 "parser.bison"
{ yyval.expr = expr_create(EXPR_POWER, yyvsp[-2].expr, yyvsp[0].expr); }
break;
case 75:
#line 313 "parser.bison"
{ yyval.expr = expr_create(yyvsp[-1].n, 0, yyvsp[0].expr); }
break;
case 76:
#line 317 "parser.bison"
{ yyval.n = EXPR_UNARY_NEG; }
break;
case 77:
#line 319 "parser.bison"
{ yyval.n = EXPR_NOT; }
break;
case 79:
#line 324 "parser.bison"
{ yyval.expr = expr_create(EXPR_INCREMENT, yyvsp[-1].expr, 0); }
break;
case 80:
#line 326 "parser.bison"
{ yyval.expr = expr_create(EXPR_DECREMENT, yyvsp[-1].expr, 0); }
break;
case 82:
#line 331 "parser.bison"
{ yyval.expr = expr_create(EXPR_LEFTBRACKET, yyvsp[-3].expr, yyvsp[-1].expr); }
break;
case 83:
#line 333 "parser.bison"
{ yyval.expr = expr_create(EXPR_LEFTPARENTHESS, yyvsp[-3].expr, yyvsp[-1].expr); }
break;
case 85:
#line 338 "parser.bison"
{ yyval.expr = expr_create_name(yyvsp[0].str); }
break;
case 86:
#line 340 "parser.bison"
{ yyval.expr = expr_create(EXPR_LEFTPARENTHESS, 0, yyvsp[-1].expr); }
break;
case 87:
#line 344 "parser.bison"
{ yyval.expr = expr_create_integer_literal(yyvsp[0].n); }
break;
case 88:
#line 346 "parser.bison"
{ yyval.expr = expr_create_character_literal(yyvsp[0].str); }
break;
case 89:
#line 348 "parser.bison"
{ yyval.expr = expr_create_string_literal(yyvsp[0].str); }
break;
case 90:
#line 350 "parser.bison"
{ yyval.expr = expr_create_boolean_literal(1); }
break;
case 91:
#line 352 "parser.bison"
{ yyval.expr = expr_create_boolean_literal(0); }
break;
#line 979 "parser.tab.c"
    }
    yyssp -= yym;
    yystate = *yyssp;
    yyvsp -= yym;
    yym = yylhs[yyn];
    if (yystate == 0 && yym == 0)
    {
#if YYDEBUG
        if (yydebug)
            printf("%sdebug: after reduction, shifting from state 0 to\
 state %d\n", YYPREFIX, YYFINAL);
#endif
        yystate = YYFINAL;
        *++yyssp = YYFINAL;
        *++yyvsp = yyval;
        if (yychar < 0)
        {
            if ((yychar = yylex()) < 0) yychar = 0;
#if YYDEBUG
            if (yydebug)
            {
                yys = 0;
                if (yychar <= YYMAXTOKEN) yys = yyname[yychar];
                if (!yys) yys = "illegal-symbol";
                printf("%sdebug: state %d, reading %d (%s)\n",
                        YYPREFIX, YYFINAL, yychar, yys);
            }
#endif
        }
        if (yychar == 0) goto yyaccept;
        goto yyloop;
    }
    if ((yyn = yygindex[yym]) && (yyn += yystate) >= 0 &&
            yyn <= YYTABLESIZE && yycheck[yyn] == yystate)
        yystate = yytable[yyn];
    else
        yystate = yydgoto[yym];
#if YYDEBUG
    if (yydebug)
        printf("%sdebug: after reduction, shifting from state %d \
to state %d\n", YYPREFIX, *yyssp, yystate);
#endif
    if (yyssp >= yysslim && yygrowstack())
    {
        goto yyoverflow;
    }
    *++yyssp = yystate;
    *++yyvsp = yyval;
    goto yyloop;

yyoverflow:
    yyerror("yacc stack overflow");

yyabort:
    return (1);

yyaccept:
    return (0);
}
