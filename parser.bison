/*
Declare token types at the top of the bison file,
causing them to be automatically generated in parser.tab.h
for use by scanner.c.
*/

%token TOKEN_ARRAY
%token TOKEN_BOOLEAN
%token TOKEN_CHAR
%token TOKEN_ELSE
%token TOKEN_FALSE
%token TOKEN_FOR
%token TOKEN_FUNCTION
%token TOKEN_IF
%token TOKEN_INTEGER
%token TOKEN_PRINT
%token TOKEN_RETURN
%token TOKEN_STRING
%token TOKEN_TRUE
%token TOKEN_VOID
%token TOKEN_WHILE
%token TOKEN_IDENT
%token TOKEN_INTEGER_LITERAL
%token TOKEN_CHAR_LITERAL
%token TOKEN_STRING_LITERAL
%token TOKEN_COMMENT_C
%token TOKEN_COMMENT_CPLUSPLUS
%token TOKEN_OP_LEFTPARENTHESS
%token TOKEN_OP_RIGHTPARENTHESS
%token TOKEN_OP_LEFTBRACKET
%token TOKEN_OP_RIGHTBRACKET
%token TOKEN_OP_INCREMENT
%token TOKEN_OP_DECREMENT
%token TOKEN_OP_NOT
%token TOKEN_OP_POWER
%token TOKEN_OP_MUL
%token TOKEN_OP_DIV
%token TOKEN_OP_MOD
%token TOKEN_OP_ADD
%token TOKEN_OP_SUB
%token TOKEN_OP_LE
%token TOKEN_OP_LT
%token TOKEN_OP_GE
%token TOKEN_OP_GT
%token TOKEN_OP_EQ
%token TOKEN_OP_UNEQ
%token TOKEN_OP_AND
%token TOKEN_OP_OR
%token TOKEN_OP_ASSIGN
%token TOKEN_LEFTCURLY
%token TOKEN_RIGHTCURLY
%token TOKEN_COLON
%token TOKEN_COMMA
%token TOKEN_SEMICOLON
%token TOKEN_ERROR


%{

#include <stdio.h>

/* 
#include "expr.h" 
*/

/*
YYSTYPE is the lexical value returned by each rule in a bison grammar.
By default, it is an integer. In this example, we are returning a pointer to an expression.
*/

//#define YYSTYPE struct expr *

/*
Clunky: Manually declare the interface to the scanner generated by flex. 
*/

extern char *yytext;
extern int yylex();
extern int yyerror( char *str );

/*
Clunky: Keep the final result of the parse in a global variable,
so that it can be retrieved by main().
*/

/*
struct expr * parser_result = 0;
*/

%}

%%

/* Here is the grammar: program is the start symbol. */


stmt_list_opt: /* nothing */
	| stmt_list
	;

stmt_list: stmt
	| stmt_list stmt
	;

stmt: expr_stmt
	| compound_stmt
	| if_stmt
	| for_stmt
	| return_stmt
	;

expr_stmt: expr TOKEN_SEMICOLON
	;

compound_stmt: TOKEN_LEFTCURLY stmt_list_opt TOKEN_RIGHTCURLY
	;


if_stmt: TOKEN_IF TOKEN_OP_LEFTPARENTHESS expr TOKEN_OP_RIGHTPARENTHESS stmt TOKEN_ELSE stmt
	;

for_stmt: TOKEN_OP_LEFTPARENTHESS expr_opt TOKEN_SEMICOLON expr_opt TOKEN_SEMICOLON expr_opt TOKEN_OP_RIGHTPARENTHESS stmt
	;

return_stmt: TOKEN_RETURN expr TOKEN_SEMICOLON
	;

expr_opt: /* nothing */
	| expr
	;

expr: assignment_expr
	| expr TOKEN_COMMA assignment_expr
	;

assignment_expr: logical_and_expr
	| unary_expr TOKEN_OP_ASSIGN assignment_expr
	;

logical_and_expr: logical_or_expr
	| logical_and_expr TOKEN_OP_AND logical_or_expr
	;

logical_or_expr: equality_expr
	| logical_or_expr TOKEN_OP_OR equality_expr
	;

equality_expr: relational_expr
	| equality_expr TOKEN_OP_EQ relational_expr
	| equality_expr TOKEN_OP_UNEQ relational_expr
	;

relational_expr: add_expr
	| relational_expr TOKEN_OP_LT add_expr
	| relational_expr TOKEN_OP_LE add_expr
	| relational_expr TOKEN_OP_GT add_expr
	| relational_expr TOKEN_OP_GE add_expr
	;

add_expr: mul_expr
	| add_expr TOKEN_OP_ADD mul_expr
	| add_expr TOKEN_OP_SUB mul_expr
	;

mul_expr: unary_expr
	| mul_expr TOKEN_OP_MUL unary_expr
	| mul_expr TOKEN_OP_DIV unary_expr
	| mul_expr TOKEN_OP_MOD unary_expr
	| mul_expr TOKEN_OP_POWER unary_expr
	;

unary_expr: postfix_expr
	| unary_operator unary_expr
	;

unary_operator: TOKEN_OP_SUB
	| TOKEN_OP_NOT
	;

postfix_expr: primary_expr
	| postfix_expr TOKEN_OP_LEFTBRACKET expr TOKEN_OP_RIGHTBRACKET
	| postfix_expr TOKEN_OP_LEFTPARENTHESS TOKEN_OP_RIGHTPARENTHESS /* function call without arguments */ 
	| postfix_expr TOKEN_OP_LEFTPARENTHESS argument_expr_list TOKEN_OP_RIGHTPARENTHESS /* function call with arguments */
	| postfix_expr TOKEN_OP_INCREMENT
	| postfix_expr TOKEN_OP_DECREMENT
	;

argument_expr_list: assignment_expr
	| argument_expr_list TOKEN_COMMA assignment_expr
	;

/* need more work */
primary_expr: TOKEN_IDENT
	| constant
	| TOKEN_STRING_LITERAL
	TOKEN_OP_LEFTPARENTHESS expr TOKEN_OP_RIGHTPARENTHESS
	;

constant: TOKEN_INTEGER_LITERAL
	| TOKEN_CHAR_LITERAL
	;
%%

/*
This function will be called by bison if the parse should
encounter an error.  In principle, "str" will contain something
useful.  In practice, it often does not.
*/

int yyerror( char *str )
{
	printf("parse error: %s\n",str);
}

main()
{
	yyparse();
}
