/*
Declare token types at the top of the bison file,
causing them to be automatically generated in parser.tab.h
for use by scanner.c.
*/

%token TOKEN_ARRAY
%token TOKEN_BOOLEAN
%token TOKEN_CHAR
%token TOKEN_ELSE
%token TOKEN_FALSE
%token TOKEN_FOR
%token TOKEN_FUNCTION
%token TOKEN_IF
%token TOKEN_INTEGER
%token TOKEN_PRINT
%token TOKEN_RETURN
%token TOKEN_STRING
%token TOKEN_TRUE
%token TOKEN_VOID
%token TOKEN_WHILE
%token TOKEN_IDENT
%token TOKEN_INTEGER_LITERAL
%token TOKEN_CHAR_LITERAL
%token TOKEN_STRING_LITERAL
%token TOKEN_COMMENT_C
%token TOKEN_COMMENT_CPLUSPLUS
%token TOKEN_OP_LEFTPARENTHESS
%token TOKEN_OP_RIGHTPARENTHESS
%token TOKEN_OP_LEFTBRACKET
%token TOKEN_OP_RIGHTBRACKET
%token TOKEN_OP_INCREMENT
%token TOKEN_OP_DECREMENT
%token TOKEN_OP_NOT
%token TOKEN_OP_POWER
%token TOKEN_OP_MUL
%token TOKEN_OP_DIV
%token TOKEN_OP_MOD
%token TOKEN_OP_ADD
%token TOKEN_OP_SUB
%token TOKEN_OP_LE
%token TOKEN_OP_LT
%token TOKEN_OP_GE
%token TOKEN_OP_GT
%token TOKEN_OP_EQ
%token TOKEN_OP_UNEQ
%token TOKEN_OP_AND
%token TOKEN_OP_OR
%token TOKEN_OP_ASSIGN
%token TOKEN_LEFTCURLY
%token TOKEN_RIGHTCURLY
%token TOKEN_COLON
%token TOKEN_COMMA
%token TOKEN_SEMICOLON
%token TOKEN_ERROR


%{

#include <stdio.h>
#include "type.h"

/* 
#include "expr.h" 
*/

/*
YYSTYPE is the lexical value returned by each rule in a bison grammar.
By default, it is an integer. In this example, we are returning a pointer to an expression.
*/

#define YYSTYPE struct type *

/*
Clunky: Manually declare the interface to the scanner generated by flex. 
*/

extern char *yytext;
extern int yylex();
extern int yyerror( char *str );

/*
Clunky: Keep the final result of the parse in a global variable,
so that it can be retrieved by main().
*/

struct type *parser_result = 0;

%}

%%

/* Here is the grammar: translation_unit is the start symbol. */

/* an empty files is legal in cminor: translation_unit can be empty */
translation_unit: translation_unit external_decl
	| /* nothing */
	;

external_decl: decl
	| func_definition
	;

func_definition: TOKEN_IDENT TOKEN_COLON type TOKEN_OP_ASSIGN compound_stmt
	;
		{ fprintf(stdout, "function definition\n\n"); type_print($3); }

decl: TOKEN_IDENT TOKEN_COLON type TOKEN_OP_ASSIGN initializer TOKEN_SEMICOLON  /* declaration with initialization */
		{ fprintf(stdout, "declaration with initialziation\n\n"); type_print($3); }
	| TOKEN_IDENT TOKEN_COLON type TOKEN_SEMICOLON /* declaration without initialization */
		{ fprintf(stdout, "declaration without initialziation\n\n"); type_print($3); }
	;

initializer: expr
	| TOKEN_LEFTCURLY initializer_list TOKEN_RIGHTCURLY
	;

initializer_list: initializer
	| initializer_list TOKEN_COMMA initializer
	;

param_list_opt: /* nothing */
	| param_list
	;

param_list: TOKEN_IDENT TOKEN_COLON type 
		{ $$ = param_list_create((char *)$1, (struct type *)$3, 0); }
	| TOKEN_IDENT TOKEN_COLON type TOKEN_COMMA param_list /* */
		{ $$ = param_list_create((char *)$1, (struct type *)$3, (struct param_list *)$4); }
	;

type: TOKEN_INTEGER
		{ $$ = type_create(TYPE_INTEGER, 0, 0); }
	| TOKEN_CHAR
		{ $$ = type_create(TYPE_CHARACTER, 0, 0); }
	| TOKEN_BOOLEAN
		{ $$ = type_create(TYPE_BOOLEAN, 0, 0); }
	| TOKEN_STRING
		{ $$ = type_create(TYPE_STRING, 0, 0); }
	| TOKEN_VOID
		{ $$ = type_create(TYPE_VOID, 0, 0); }
	| TOKEN_ARRAY TOKEN_OP_LEFTBRACKET TOKEN_OP_RIGHTBRACKET type
		{ $$ = type_create(TYPE_ARRAY, 0, (struct type *)$4); }
	| TOKEN_ARRAY TOKEN_OP_LEFTBRACKET logical_or_expr TOKEN_OP_RIGHTBRACKET type
		{ $$ = type_create(TYPE_ARRAY, 0, (struct type *)$5); }
	| TOKEN_FUNCTION type TOKEN_OP_LEFTPARENTHESS param_list_opt TOKEN_OP_RIGHTPARENTHESS
		{ $$ = type_create(TYPE_FUNCTION, (struct param_list *)$4, (struct type *)$2); }
	;

stmt_list: /* nothing */ 
	| stmt_list stmt
	;

stmt: matched_stmt
	| unmatched_stmt
	;

matched_stmt: external_decl
	| expr_stmt
	| compound_stmt
	| return_stmt
	| print_stmt
	| TOKEN_FOR TOKEN_OP_LEFTPARENTHESS expr_opt TOKEN_SEMICOLON expr_opt TOKEN_SEMICOLON expr_opt TOKEN_OP_RIGHTPARENTHESS matched_stmt
		{ fprintf(stdout, "matched for statement\n\n"); }
	| TOKEN_IF TOKEN_OP_LEFTPARENTHESS expr TOKEN_OP_RIGHTPARENTHESS matched_stmt TOKEN_ELSE matched_stmt
		{ fprintf(stdout, "matched if statement\n\n"); }
	;

unmatched_stmt: TOKEN_IF TOKEN_OP_LEFTPARENTHESS expr TOKEN_OP_RIGHTPARENTHESS stmt
		{ fprintf(stdout, "unmatched if statement\n\n"); }
	| TOKEN_IF TOKEN_OP_LEFTPARENTHESS expr TOKEN_OP_RIGHTPARENTHESS matched_stmt TOKEN_ELSE unmatched_stmt
		{ fprintf(stdout, "unmatched if statement\n\n"); }
	| TOKEN_FOR TOKEN_OP_LEFTPARENTHESS expr_opt TOKEN_SEMICOLON expr_opt TOKEN_SEMICOLON expr_opt TOKEN_OP_RIGHTPARENTHESS unmatched_stmt
		{ fprintf(stdout, "unmatched for statement\n\n"); }
	;

expr_stmt: expr TOKEN_SEMICOLON
		{ fprintf(stdout, "expression statement\n\n"); }
	;

compound_stmt: TOKEN_LEFTCURLY stmt_list TOKEN_RIGHTCURLY
		{ fprintf(stdout, "compound statement\n\n"); }
	;

return_stmt: TOKEN_RETURN expr_opt TOKEN_SEMICOLON
		{ fprintf(stdout, "return statement\n\n"); }
	;

print_stmt: TOKEN_PRINT expr_list_opt TOKEN_SEMICOLON
		{ fprintf(stdout, "print statement\n\n"); }
	;

expr_list_opt: /* nothing */
	| expr_list
	;

expr_list: expr 
	| expr_list TOKEN_COMMA expr
	;

expr_opt: /* nothing */
	| expr
	;

expr: assignment_expr
	;

assignment_expr: logical_or_expr
	| unary_expr TOKEN_OP_ASSIGN assignment_expr
	;

logical_or_expr: logical_and_expr
	| logical_or_expr TOKEN_OP_OR logical_and_expr
	;

logical_and_expr: relational_expr
	| logical_and_expr TOKEN_OP_AND relational_expr
	;

/* this is different from C. In C, relational ops have higher precedence than equality ops */
relational_expr: add_expr
	| relational_expr TOKEN_OP_LT add_expr
	| relational_expr TOKEN_OP_LE add_expr
	| relational_expr TOKEN_OP_GT add_expr
	| relational_expr TOKEN_OP_GE add_expr
	| relational_expr TOKEN_OP_EQ add_expr
	| relational_expr TOKEN_OP_UNEQ add_expr
	;

add_expr: mul_expr
	| add_expr TOKEN_OP_ADD mul_expr
	| add_expr TOKEN_OP_SUB mul_expr
	;

mul_expr: power_expr
	| mul_expr TOKEN_OP_MUL power_expr
	| mul_expr TOKEN_OP_DIV power_expr
	| mul_expr TOKEN_OP_MOD power_expr
	;

power_expr: unary_expr
	| power_expr TOKEN_OP_POWER unary_expr
	;

unary_expr: increment_expr
	| unary_operator unary_expr
	;

unary_operator: TOKEN_OP_SUB
	| TOKEN_OP_NOT
	;

increment_expr: postfix_expr
	| increment_expr TOKEN_OP_INCREMENT
	| increment_expr TOKEN_OP_DECREMENT
	;

postfix_expr: primary_expr
	| postfix_expr TOKEN_OP_LEFTBRACKET expr TOKEN_OP_RIGHTBRACKET /* array subscript */
	| postfix_expr TOKEN_OP_LEFTPARENTHESS expr_list_opt TOKEN_OP_RIGHTPARENTHESS /* function call */
	;

primary_expr: TOKEN_IDENT
		{ $$ = yytext; }
	| constant
	| TOKEN_STRING_LITERAL
	| TOKEN_OP_LEFTPARENTHESS expr TOKEN_OP_RIGHTPARENTHESS /* grouping */
	;

constant: TOKEN_INTEGER_LITERAL
	| TOKEN_CHAR_LITERAL
	;
%%

/*
This function will be called by bison if the parse should
encounter an error.  In principle, "str" will contain something
useful.  In practice, it often does not.
*/

int yyerror( char *str )
{
	printf("parse error: %s\n",str);
}
