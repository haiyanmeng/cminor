/*
Declare token types at the top of the bison file,
causing them to be automatically generated in parser.tab.h
for use by scanner.c.
*/

%token TOKEN_ARRAY
%token TOKEN_BOOLEAN
%token TOKEN_CHAR
%token TOKEN_ELSE
%token TOKEN_FALSE
%token TOKEN_FOR
%token TOKEN_FUNCTION
%token TOKEN_IF
%token TOKEN_INTEGER
%token TOKEN_PRINT
%token TOKEN_RETURN
%token TOKEN_STRING
%token TOKEN_TRUE
%token TOKEN_VOID
%token TOKEN_WHILE
%token TOKEN_IDENT
%token TOKEN_INTEGER_LITERAL
%token TOKEN_CHAR_LITERAL
%token TOKEN_STRING_LITERAL
%token TOKEN_COMMENT_C
%token TOKEN_COMMENT_CPLUSPLUS
%token TOKEN_OP_LEFTPARENTHESS
%token TOKEN_OP_RIGHTPARENTHESS
%token TOKEN_OP_LEFTBRACKET
%token TOKEN_OP_RIGHTBRACKET
%token TOKEN_OP_INCREMENT
%token TOKEN_OP_DECREMENT
%token TOKEN_OP_NOT
%token TOKEN_OP_POWER
%token TOKEN_OP_MUL
%token TOKEN_OP_DIV
%token TOKEN_OP_MOD
%token TOKEN_OP_ADD
%token TOKEN_OP_SUB
%token TOKEN_OP_LE
%token TOKEN_OP_LT
%token TOKEN_OP_GE
%token TOKEN_OP_GT
%token TOKEN_OP_EQ
%token TOKEN_OP_UNEQ
%token TOKEN_OP_AND
%token TOKEN_OP_OR
%token TOKEN_OP_ASSIGN
%token TOKEN_LEFTCURLY
%token TOKEN_RIGHTCURLY
%token TOKEN_COLON
%token TOKEN_COMMA
%token TOKEN_SEMICOLON
%token TOKEN_ERROR


%{

#include <stdio.h>

/* 
#include "expr.h" 
*/

/*
YYSTYPE is the lexical value returned by each rule in a bison grammar.
By default, it is an integer. In this example, we are returning a pointer to an expression.
*/

//#define YYSTYPE struct expr *

/*
Clunky: Manually declare the interface to the scanner generated by flex. 
*/

extern char *yytext;
extern int yylex();
extern int yyerror( char *str );

/*
Clunky: Keep the final result of the parse in a global variable,
so that it can be retrieved by main().
*/

/*
struct expr * parser_result = 0;
*/

%}

%%

/* Here is the grammar: translation_unit is the start symbol. */

/* an empty files is legal in cminor: translation_unit can be empty */
translation_unit: translation_unit external_decl
	| /* nothing */
	;

external_decl: decl
	| func_definition
	;

func_definition: TOKEN_IDENT TOKEN_COLON TOKEN_FUNCTION type TOKEN_OP_LEFTPARENTHESS param_list_opt TOKEN_OP_RIGHTPARENTHESS TOKEN_OP_ASSIGN compound_stmt

decl: TOKEN_IDENT TOKEN_COLON type TOKEN_OP_ASSIGN initializer TOKEN_SEMICOLON  /* declaration with initialization */
	| TOKEN_IDENT TOKEN_COLON type TOKEN_SEMICOLON /* declaration without initialization */
	| TOKEN_IDENT TOKEN_COLON TOKEN_FUNCTION type TOKEN_OP_LEFTPARENTHESS param_list_opt TOKEN_OP_RIGHTPARENTHESS TOKEN_SEMICOLON /* function prototype */
	;

initializer: expr
	| TOKEN_LEFTCURLY initializer_list TOKEN_RIGHTCURLY
	;

initializer_list: initializer
	| initializer_list TOKEN_COMMA initializer
	;

param_list_opt: /* nothing */
	| param_list
	;

param_list: param
	| param_list TOKEN_COMMA param
	;

param: TOKEN_IDENT TOKEN_COLON type 
	;

type: TOKEN_INTEGER
	| TOKEN_CHAR
	| TOKEN_BOOLEAN
	| TOKEN_STRING
	| TOKEN_ARRAY TOKEN_OP_LEFTBRACKET TOKEN_OP_RIGHTBRACKET type
	| TOKEN_ARRAY TOKEN_OP_LEFTBRACKET logical_or_expr TOKEN_OP_RIGHTBRACKET type
	| TOKEN_VOID
	;

stmt_list: /* nothing */ 
	| stmt_list stmt
	;

stmt: expr_stmt
	| compound_stmt
	| if_stmt
	| for_stmt
	| return_stmt
	| print_stmt
	;

expr_stmt: expr TOKEN_SEMICOLON
	;

compound_stmt: TOKEN_LEFTCURLY stmt_list TOKEN_RIGHTCURLY
	;

if_stmt: TOKEN_IF TOKEN_OP_LEFTPARENTHESS expr TOKEN_OP_RIGHTPARENTHESS stmt TOKEN_ELSE stmt
	;

for_stmt: TOKEN_OP_LEFTPARENTHESS expr_opt TOKEN_SEMICOLON expr_opt TOKEN_SEMICOLON expr_opt TOKEN_OP_RIGHTPARENTHESS stmt
	;

return_stmt: TOKEN_RETURN expr_opt TOKEN_SEMICOLON
	;

print_stmt: TOKEN_PRINT expr_list_opt TOKEN_SEMICOLON
	;

expr_list_opt: /* nothing */
	| expr_list
	;

expr_list: expr 
	| expr_list TOKEN_COMMA expr
	;

expr_opt: /* nothing */
	| expr
	;

expr: assignment_expr
	;

assignment_expr: logical_or_expr
	| unary_expr TOKEN_OP_ASSIGN assignment_expr
	;

logical_or_expr: logical_and_expr
	| logical_or_expr TOKEN_OP_OR logical_and_expr
	;

logical_and_expr: relational_expr
	| logical_and_expr TOKEN_OP_AND relational_expr
	;

/* this is different from C. In C, relational ops have higher precedence than equality ops */
relational_expr: add_expr
	| relational_expr TOKEN_OP_LT add_expr
	| relational_expr TOKEN_OP_LE add_expr
	| relational_expr TOKEN_OP_GT add_expr
	| relational_expr TOKEN_OP_GE add_expr
	| relational_expr TOKEN_OP_EQ add_expr
	| relational_expr TOKEN_OP_UNEQ add_expr
	;

add_expr: mul_expr
	| add_expr TOKEN_OP_ADD mul_expr
	| add_expr TOKEN_OP_SUB mul_expr
	;

mul_expr: power_expr
	| mul_expr TOKEN_OP_MUL power_expr
	| mul_expr TOKEN_OP_DIV power_expr
	| mul_expr TOKEN_OP_MOD power_expr
	;

power_expr: unary_expr
	| power_expr TOKEN_OP_POWER unary_expr
	;

unary_expr: increment_expr
	| unary_operator unary_expr
	;

unary_operator: TOKEN_OP_SUB
	| TOKEN_OP_NOT
	;

increment_expr: postfix_expr
	| increment_expr TOKEN_OP_INCREMENT
	| increment_expr TOKEN_OP_DECREMENT
	;

postfix_expr: primary_expr
	| postfix_expr TOKEN_OP_LEFTBRACKET expr TOKEN_OP_RIGHTBRACKET /* array subscript */
	| postfix_expr TOKEN_OP_LEFTPARENTHESS expr_list_opt TOKEN_OP_RIGHTPARENTHESS /* function call */
	;

primary_expr: TOKEN_IDENT
	| constant
	| TOKEN_STRING_LITERAL
	TOKEN_OP_LEFTPARENTHESS expr TOKEN_OP_RIGHTPARENTHESS /* grouping */
	;

constant: TOKEN_INTEGER_LITERAL
	| TOKEN_CHAR_LITERAL
	;
%%

/*
This function will be called by bison if the parse should
encounter an error.  In principle, "str" will contain something
useful.  In practice, it often does not.
*/

int yyerror( char *str )
{
	printf("parse error: %s\n",str);
}

main()
{
	yyparse();
}
